function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { URL } from 'url';
import { Transform, Stream, PassThrough, pipeline } from 'stream';
import { WriteStream } from 'fs';
import { createHash } from 'crypto';
import http from 'http';
import zlib from 'zlib';
import https from 'https';

const inElectron = (() => {
  if (!process.versions.electron) {
    return false;
  }

  try {
    const electron = require('electron');

    return Boolean(electron && electron.app);
  } catch {
    return false;
  }
})();

const extractContentType = body => {
  if (typeof body === 'string') {
    return 'text/plain;charset=UTF-8';
  }

  return null;
};

const isRedirect = code => {
  if (typeof code !== 'number') return false;
  return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
};

const isValidTokenChar = ch => {
  if (ch >= 94 && ch <= 122) {
    return true;
  }

  if (ch >= 65 && ch <= 90) {
    return true;
  }

  if (ch === 45) {
    return true;
  }

  if (ch >= 48 && ch <= 57) {
    return true;
  }

  if (ch === 34 || ch === 40 || ch === 41 || ch === 44) {
    return false;
  }

  if (ch >= 33 && ch <= 46) {
    return true;
  }

  if (ch === 124 || ch === 126) {
    return true;
  }

  return false;
};

const checkIsHttpToken = val => {
  if (typeof val !== 'string' || val.length === 0) {
    return false;
  }

  if (!isValidTokenChar(val.charCodeAt(0))) {
    return false;
  }

  const len = val.length;

  if (len > 1) {
    if (!isValidTokenChar(val.charCodeAt(1))) {
      return false;
    }

    if (len > 2) {
      if (!isValidTokenChar(val.charCodeAt(2))) {
        return false;
      }

      if (len > 3) {
        if (!isValidTokenChar(val.charCodeAt(3))) {
          return false;
        }

        for (let i = 4; i < len; i += 1) {
          if (!isValidTokenChar(val.charCodeAt(i))) {
            return false;
          }
        }
      }
    }
  }

  return true;
};

const checkInvalidHeaderChar = val => {
  if (val.length < 1) {
    return false;
  }

  let c = val.charCodeAt(0);

  if (c <= 31 && c !== 9 || c > 255 || c === 127) {
    return true;
  }

  if (val.length < 2) {
    return false;
  }

  c = val.charCodeAt(1);

  if (c <= 31 && c !== 9 || c > 255 || c === 127) {
    return true;
  }

  if (val.length < 3) {
    return false;
  }

  c = val.charCodeAt(2);

  if (c <= 31 && c !== 9 || c > 255 || c === 127) {
    return true;
  }

  for (let i = 3; i < val.length; i += 1) {
    c = val.charCodeAt(i);

    if (c <= 31 && c !== 9 || c > 255 || c === 127) {
      return true;
    }
  }

  return false;
};

const sanitizeKey = name => {
  if (!checkIsHttpToken(name)) {
    throw new TypeError(`${name} is not a legal HTTP header name`);
  }

  return name.toLowerCase();
};

const sanitizeValue = value => {
  if (checkInvalidHeaderChar(value)) {
    throw new TypeError(`${value} is not a legal HTTP header value`);
  }

  return value;
};

class Headers {
  constructor() {
    let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _defineProperty(this, "map", new Map());

    _defineProperty(this, "raw", () => {
      const result = {};

      for (const [key, value] of this.map.entries()) {
        result[key] = value;
      }

      return result;
    });

    _defineProperty(this, "append", (key, value) => {
      const prev = this.get(key);

      if (!prev) {
        this.set(key, value);
      } else {
        this.set(key, Array.isArray(prev) ? [...prev, value] : [prev, value]);
      }
    });

    _defineProperty(this, "get", key => {
      const value = this.map.get(sanitizeKey(key));

      if (typeof value === 'string') {
        return value;
      }

      if (Array.isArray(value)) {
        return value.join(',');
      }

      return null;
    });

    _defineProperty(this, "has", key => this.map.has(sanitizeKey(key)));

    _defineProperty(this, "set", (key, value) => {
      const data = Array.isArray(value) ? value.map(sanitizeValue) : sanitizeValue(value);
      this.map.set(sanitizeKey(key), data);
    });

    _defineProperty(this, "delete", key => {
      this.map.delete(sanitizeKey(key));
    });

    for (const [key, value] of Object.entries(init)) {
      if (value) {
        this.set(key, value);
      }
    }
  }

}

class ElectronAdapter {
  constructor() {
    _defineProperty(this, "electron", require('electron'));
  }

  whenReady() {
    return this.electron.app.whenReady();
  }

  request(options) {
    return this.electron.net.request(options);
  }

  getDefaultSession() {
    return this.electron.session.defaultSession;
  }

}

class BlobImpl {
  constructor(blobParts, options) {
    _defineProperty(this, "buffer", void 0);

    _defineProperty(this, "closed", void 0);

    _defineProperty(this, "privateType", '');

    const buffers = [];

    if (blobParts) {
      if (!blobParts || typeof blobParts !== 'object' || blobParts instanceof Date || blobParts instanceof RegExp) {
        throw new TypeError('Blob parts must be objects that are not Dates or RegExps');
      }

      for (let i = 0, l = Number(blobParts.length); i < l; i += 1) {
        const part = blobParts[i];
        let buf;

        if (part instanceof Buffer) {
          buf = part;
        } else if (part instanceof ArrayBuffer) {
          buf = Buffer.from(new Uint8Array(part));
        } else if (part instanceof BlobImpl) {
          buf = part.buffer;
        } else if (ArrayBuffer.isView(part)) {
          buf = Buffer.from(new Uint8Array(part.buffer, part.byteOffset, part.byteLength));
        } else {
          buf = Buffer.from(typeof part === 'string' ? part : String(part));
        }

        buffers.push(buf);
      }
    }

    this.buffer = Buffer.concat(buffers);
    this.closed = false;
    const type = options && options.type !== undefined && String(options.type).toLowerCase();

    if (type && !/[^\u0020-\u007E]/.test(type)) {
      this.privateType = type;
    }
  }

  get size() {
    return this.buffer.length;
  }

  get type() {
    return this.privateType;
  }

  get content() {
    return this.buffer;
  }

  get isClosed() {
    return this.closed;
  }

  slice(start, end, type) {
    const {
      size,
      buffer
    } = this;
    let relativeStart;
    let relativeEnd;

    if (start === void 0) {
      relativeStart = 0;
    } else if (start < 0) {
      relativeStart = Math.max(size + start, 0);
    } else {
      relativeStart = Math.min(start, size);
    }

    if (end === void 0) {
      relativeEnd = size;
    } else if (end < 0) {
      relativeEnd = Math.max(size + end, 0);
    } else {
      relativeEnd = Math.min(end, size);
    }

    const span = Math.max(relativeEnd - relativeStart, 0);
    const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
    const blob = new BlobImpl([], {
      type: type || this.type
    });
    blob.buffer = slicedBuffer;
    blob.closed = this.closed;
    return blob;
  }

  close() {
    this.closed = true;
  }

  toString() {
    return '[object Blob]';
  }

}

const newError = (message, code) => {
  const error = new Error(message);
  error.code = code;
  return error;
};

class DigestTransform extends Transform {
  get actual() {
    return this._actual;
  }

  constructor(options) {
    super();

    _defineProperty(this, "digester", void 0);

    _defineProperty(this, "_actual", null);

    _defineProperty(this, "expected", void 0);

    _defineProperty(this, "algorithm", void 0);

    _defineProperty(this, "encoding", void 0);

    _defineProperty(this, "isValidateOnEnd", true);

    const {
      expected,
      algorithm = 'md5',
      encoding = 'base64'
    } = options;
    this.expected = expected;
    this.algorithm = algorithm;
    this.encoding = encoding;
    this.digester = createHash(algorithm);
  }

  _transform(chunk, encoding, callback) {
    this.digester.update(chunk);
    callback(null, chunk);
  }

  _flush(callback) {
    this._actual = this.digester.digest(this.encoding);

    if (this.isValidateOnEnd) {
      try {
        this.validate();
      } catch (e) {
        callback(e);
        return;
      }
    }

    callback(null);
  }

  validate() {
    if (this._actual == null) {
      throw newError('Not finished yet', 'ERR_STREAM_NOT_FINISHED');
    }

    if (this._actual !== this.expected) {
      throw newError(`${this.algorithm} checksum mismatch, expected ${this.expected}, got ${this._actual}`, 'ERR_CHECKSUM_MISMATCH');
    }

    return null;
  }

}

class ProgressCallbackTransform extends Transform {
  constructor(total, onProgress) {
    super();

    _defineProperty(this, "start", Date.now());

    _defineProperty(this, "transferred", 0);

    _defineProperty(this, "delta", 0);

    _defineProperty(this, "total", void 0);

    _defineProperty(this, "onProgress", void 0);

    _defineProperty(this, "nextUpdate", this.start + 1000);

    this.total = total;
    this.onProgress = onProgress;
  }

  _transform(chunk, encoding, callback) {
    const chunkLength = chunk.length;
    this.transferred += chunkLength;
    this.delta += chunkLength;

    if (this.total >= this.transferred) {
      const now = Date.now();

      if (now >= this.nextUpdate) {
        this.nextUpdate = now + 1000;
        this.onProgress({
          total: this.total,
          delta: this.delta,
          transferred: this.transferred,
          percent: this.transferred / this.total * 100,
          bytesPerSecond: Math.round(this.transferred / ((now - this.start) / 1000))
        });
        this.delta = 0;
      }
    }

    callback(null, chunk);
  }

  _flush(callback) {
    const {
      total,
      transferred
    } = this;
    const totalChunk = transferred > total ? transferred : total;
    this.onProgress({
      total: totalChunk,
      delta: this.delta,
      transferred: totalChunk,
      percent: 100,
      bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1000))
    });
    this.delta = 0;
    callback(null);
  }

}

class ResponseImpl {
  constructor(body, options) {
    _defineProperty(this, "disturbed", void 0);

    _defineProperty(this, "body", void 0);

    _defineProperty(this, "config", void 0);

    _defineProperty(this, "consumeResponse", () => {
      const {
        requestURL,
        size
      } = this.config;

      if (this.disturbed) {
        return Promise.reject(new Error(`Response used already for: ${requestURL}`));
      }

      this.disturbed = true;

      if (this.body === null) {
        return Promise.resolve(Buffer.alloc(0));
      }

      if (typeof this.body === 'string') {
        return Promise.resolve(Buffer.from(this.body));
      }

      if (this.body instanceof BlobImpl) {
        return Promise.resolve(this.body.content);
      }

      if (Buffer.isBuffer(this.body)) {
        return Promise.resolve(this.body);
      }

      if (!(this.body instanceof Stream)) {
        return Promise.resolve(Buffer.alloc(0));
      }

      const accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Promise((resolve, reject) => {
        this.body.on("error", err => {
          reject(new Error(`Invalid response body while trying to fetch ${requestURL}: ${err.message}`));
        });
        this.body.on("data", chunk => {
          if (abort || chunk === null) {
            return;
          }

          if (size && accumBytes + chunk.length > size) {
            abort = true;
            reject(new Error(`Content size at ${requestURL} over limit: ${size}`));
            this.body.emit("cancel-request");
            return;
          }

          accumBytes += chunk.length;
          accum.push(chunk);
        });
        this.body.on("end", () => {
          if (abort) {
            return;
          }

          resolve(Buffer.concat(accum, accumBytes));
        });
      });
    });

    _defineProperty(this, "download", async (fileOut, onProgress, validateOptions) => {
      const feedStreams = [];

      if (typeof onProgress === 'function') {
        const contentLength = Number(this.config.headers.get("content-length"));
        feedStreams.push(new ProgressCallbackTransform(contentLength, onProgress));
      }

      if (validateOptions) {
        feedStreams.push(new DigestTransform(validateOptions));
      }

      feedStreams.push(fileOut);
      return new Promise((resolve, reject) => {
        let lastStream = this.stream;

        for (const stream of feedStreams) {
          stream.on('error', error => {
            reject(error);
          });
          lastStream = lastStream.pipe(stream);
        }

        fileOut.once('finish', () => {
          if (fileOut instanceof WriteStream && typeof fileOut.close === 'function') {
            fileOut.close();
          }

          resolve();
        });
      });
    });

    _defineProperty(this, "arrayBuffer", async () => {
      const buf = await this.consumeResponse();
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    });

    _defineProperty(this, "blob", async () => {
      const contentType = this.config.headers.get("content-Type") || '';
      const buffer = await this.consumeResponse();
      const blob = new BlobImpl([buffer], {
        type: contentType.toLowerCase()
      });
      return blob;
    });

    _defineProperty(this, "text", async () => {
      const buffer = await this.consumeResponse();
      return buffer.toString();
    });

    _defineProperty(this, "json", async () => {
      const buffer = await this.consumeResponse();
      const text = buffer.toString();

      try {
        return JSON.parse(text);
      } catch {
        throw new Error(text);
      }
    });

    _defineProperty(this, "buffer", () => {
      return this.consumeResponse();
    });

    this.body = body;
    this.config = options;
    this.disturbed = false;
  }

  get ok() {
    const {
      statusCode
    } = this.config;
    return statusCode >= 200 && statusCode < 300;
  }

  get headers() {
    return this.config.headers.raw();
  }

  get stream() {
    if (this.disturbed) {
      throw new Error(`Response used already for: ${this.config.requestURL}`);
    }

    return this.body;
  }

}

class ElectronRequestClient {
  constructor(_options) {
    _defineProperty(this, "electronAdapter", inElectron ? new ElectronAdapter() : null);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "redirectCount", 0);

    _defineProperty(this, "timeoutId", null);

    _defineProperty(this, "clearRequestTimeout", () => {
      if (this.timeoutId === null) return;
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    });

    _defineProperty(this, "createRequest", async () => {
      if (this.electronAdapter === null) {
        throw new Error('Error in environmental judgment');
      }

      await this.electronAdapter.whenReady();
      const {
        requestURL,
        parsedURL: {
          protocol,
          host,
          hostname,
          port,
          pathname,
          origin,
          search
        },
        method,
        session,
        useSessionCookies,
        headers
      } = this.options;
      const options = {
        method,
        url: `${requestURL}${pathname}${search || ''}`,
        session: session || this.electronAdapter.getDefaultSession(),
        useSessionCookies,
        protocol,
        host,
        hostname,
        origin,
        port: Number(port)
      };
      const clientRequest = this.electronAdapter.request(options);

      for (const [key, value] of Object.entries(headers.raw())) {
        if (Array.isArray(value)) {
          for (const v of value) {
            clientRequest.setHeader(key, v);
          }
        } else {
          clientRequest.setHeader(key, value);
        }
      }

      return clientRequest;
    });

    _defineProperty(this, "send", async () => {
      const {
        method,
        followRedirect,
        maxRedirectCount,
        requestURL,
        parsedURL,
        size,
        username,
        password,
        timeout,
        body: requestBody
      } = this.options;
      const clientRequest = await this.createRequest();

      const cancelRequest = () => {
        clientRequest.abort();
      };

      const writeToRequest = () => {
        if (requestBody === null) {
          clientRequest.end();
        } else if (requestBody instanceof Stream) {
          requestBody.pipe(new PassThrough()).pipe(clientRequest);
        } else {
          clientRequest.write(requestBody);
          clientRequest.end();
        }
      };

      const bindRequestEvent = (onFulfilled, onRejected) => {
        if (timeout) {
          this.timeoutId = setTimeout(() => {
            onRejected(new Error(`Electron request timeout in ${timeout} ms`));
          }, timeout);
        }

        clientRequest.on("error", onRejected);
        clientRequest.on("abort", () => {
          onRejected(new Error('Electron request was aborted by the server'));
        });
        clientRequest.on("login", (authInfo, callback) => {
          if (username && password) {
            callback(username, password);
          } else {
            onRejected(new Error(`Login event received from ${authInfo.host} but no credentials provided`));
          }
        });
        clientRequest.on("response", res => {
          this.clearRequestTimeout();
          const {
            statusCode = 200,
            headers: responseHeaders
          } = res;
          const headers = new Headers(responseHeaders);

          if (isRedirect(statusCode) && followRedirect) {
            if (maxRedirectCount && this.redirectCount >= maxRedirectCount) {
              onRejected(new Error(`Maximum redirect reached at: ${requestURL}`));
            }

            if (!headers.get("location")) {
              onRejected(new Error(`Redirect location header missing at: ${requestURL}`));
            }

            if (statusCode === 303 || (statusCode === 301 || statusCode === 302) && method === "POST") {
              this.options.method = "GET";
              this.options.body = null;
              this.options.headers.delete("content-length");
            }

            this.redirectCount += 1;
            this.options.parsedURL = new URL(String(headers.get("location")), parsedURL.toString());
            onFulfilled(this.send());
          }

          const responseBody = pipeline(res, new PassThrough(), error => {
            if (error !== null) {
              onRejected(error);
            }
          });
          responseBody.on("cancel-request", cancelRequest);
          onFulfilled(new ResponseImpl(responseBody, {
            requestURL,
            statusCode,
            headers,
            size
          }));
        });
      };

      return new Promise((resolve, reject) => {
        const onRejected = reason => {
          this.clearRequestTimeout();
          cancelRequest();
          reject(reason);
        };

        bindRequestEvent(resolve, onRejected);
        writeToRequest();
      });
    });

    this.options = _options;
  }

}

const adapterForHttp = protocol => {
  if (protocol === 'http:') {
    return http;
  }

  if (protocol === 'https:') {
    return https;
  }

  throw new TypeError('Only HTTP(S) protocols are supported');
};

class NativeRequestClient {
  constructor(_options2) {
    _defineProperty(this, "options", void 0);

    _defineProperty(this, "redirectCount", 0);

    _defineProperty(this, "createRequest", () => {
      const {
        parsedURL: {
          protocol,
          host,
          hostname,
          port,
          pathname,
          search
        },
        headers,
        method
      } = this.options;
      const options = {
        protocol,
        host,
        hostname,
        port,
        path: `${pathname}${search || ''}`,
        headers: headers.raw(),
        method
      };
      return adapterForHttp(protocol).request(options);
    });

    _defineProperty(this, "send", () => {
      const {
        method,
        followRedirect,
        maxRedirectCount,
        requestURL,
        parsedURL,
        size,
        timeout,
        body: requestBody
      } = this.options;
      const clientRequest = this.createRequest();

      const cancelRequest = () => {
        clientRequest.destroy();
      };

      const writeToRequest = () => {
        if (requestBody === null) {
          clientRequest.end();
        } else if (requestBody instanceof Stream) {
          requestBody.pipe(clientRequest);
        } else {
          clientRequest.write(requestBody);
          clientRequest.end();
        }
      };

      const bindRequestEvent = (onFulfilled, onRejected) => {
        if (timeout) {
          clientRequest.setTimeout(timeout, () => {
            onRejected(new Error(`NodeJS request timeout in ${timeout} ms`));
          });
        }

        clientRequest.on("error", onRejected);
        clientRequest.on("abort", () => {
          onRejected(new Error('NodeJS request was aborted by the server'));
        });
        clientRequest.on("response", res => {
          const {
            statusCode = 200,
            headers: responseHeaders
          } = res;
          const headers = new Headers(responseHeaders);

          if (isRedirect(statusCode) && followRedirect) {
            if (maxRedirectCount && this.redirectCount >= maxRedirectCount) {
              onRejected(new Error(`Maximum redirect reached at: ${requestURL}`));
            }

            if (!headers.get("location")) {
              onRejected(new Error(`Redirect location header missing at: ${requestURL}`));
            }

            if (statusCode === 303 || (statusCode === 301 || statusCode === 302) && method === "POST") {
              this.options.method = "GET";
              this.options.body = null;
              this.options.headers.delete("content-length");
            }

            this.redirectCount += 1;
            this.options.parsedURL = new URL(String(headers.get("location")), parsedURL.toString());
            onFulfilled(this.send());
          }

          const pumpCallback = error => {
            if (error !== null) {
              onRejected(error);
            }
          };

          let responseBody = pipeline(res, new PassThrough(), pumpCallback);
          responseBody.on("cancel-request", cancelRequest);

          const resolveResponse = () => {
            onFulfilled(new ResponseImpl(responseBody, {
              requestURL,
              statusCode,
              headers,
              size
            }));
          };

          const codings = headers.get("content-encoding");

          if (method !== "HEAD" && codings !== null && statusCode !== 204 && statusCode !== 304) {
            switch (codings) {
              case "br":
                responseBody = pipeline(responseBody, zlib.createBrotliDecompress(), pumpCallback);
                break;

              case "gzip":
              case `x-${"gzip"}`:
                responseBody = pipeline(responseBody, zlib.createGunzip(), pumpCallback);
                break;

              case "deflate":
              case `x-${"deflate"}`:
                pipeline(res, new PassThrough(), pumpCallback).once('data', chunk => {
                  if ((chunk[0] & 0x0f) === 0x08) {
                    responseBody = pipeline(responseBody, zlib.createInflate(), pumpCallback);
                  } else {
                    responseBody = pipeline(responseBody, zlib.createInflateRaw(), pumpCallback);
                  }

                  resolveResponse();
                });
                return;
            }
          }

          resolveResponse();
        });
      };

      return new Promise((resolve, reject) => {
        const onRejected = reason => {
          cancelRequest();
          reject(reason);
        };

        bindRequestEvent(resolve, onRejected);
        writeToRequest();
      });
    });

    this.options = _options2;
  }

}

const DEFAULT_OPTIONS = {
  method: 'GET',
  body: null,
  followRedirect: true,
  maxRedirectCount: 20,
  timeout: 0,
  size: 0,
  useSessionCookies: true,
  useNative: false
};
const SUPPORTED_COMPRESSIONS = ["gzip", "deflate", "br"];

const getRequestOptions = constructorOptions => {
  const options = { ...DEFAULT_OPTIONS,
    ...constructorOptions
  };
  const method = options.method.toUpperCase();
  const {
    body,
    requestURL,
    query,
    headers: headerOptions
  } = options;

  if (body !== null && (method === "GET" || method === "HEAD")) {
    throw new TypeError('Request with GET/HEAD method cannot have body');
  }

  const parsedURL = new URL(requestURL);

  if (!parsedURL.protocol || !parsedURL.hostname) {
    throw new TypeError('Only absolute URLs are supported');
  }

  if (!/^https?:$/.test(parsedURL.protocol)) {
    throw new TypeError('Only HTTP(S) protocols are supported');
  }

  if (query) {
    for (const [queryKey, queryValue] of Object.entries(query)) {
      parsedURL.searchParams.append(queryKey, queryValue);
    }
  }

  const headers = new Headers(headerOptions);
  headers.delete("content-length");
  headers.set("accept-encoding", SUPPORTED_COMPRESSIONS.join(','));

  if (!headers.has("accept")) {
    headers.set("accept", '*/*');
  }

  if (!headers.has("connection")) {
    headers.set("connection", 'close');
  }

  if (body && !headers.has("content-Type")) {
    const contentType = extractContentType(body);

    if (contentType) {
      headers.append("content-Type", contentType);
    }
  }

  return { ...options,
    method,
    parsedURL,
    headers
  };
};

class Request {
  constructor(constructorOptions) {
    _defineProperty(this, "client", void 0);

    _defineProperty(this, "send", () => {
      return this.client.send();
    });

    const options = getRequestOptions(constructorOptions);
    this.client = !options.useNative && inElectron ? new ElectronRequestClient(options) : new NativeRequestClient(options);
  }

}

const main = function (requestURL) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const request = new Request({
    requestURL,
    ...options
  });
  return request.send();
};

export { main as default };
